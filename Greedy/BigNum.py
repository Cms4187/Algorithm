#큰 수의 법칙 - Greedy

#다양한 수의 배열이 있으면 주어진 수를 M번 더해 가장 큰 수를 만드는 법칙
#배열의 특정 인덱스에 해당하는 수가 연속해서 K번 이상 더할 수는 없음

#예) 2,4,5,4,6이 있고 M=8, K=3이면 6+6+6+5+6+6+6+5 = 46이 된다.

#단, 서로 다른 인덱스에 해당 하는 수가 같아도 다른 것으로 간주한다.

#3,4,3,4,3이 있고 M=7, K=2면 4+4+4+4+4+4+4 = 28이 된다.


#입력 조건: 첫째 줄에 N(2~1,000), M(1~10,000), K(1~10,000)의 자연수 주어짐, 공백으로 구분
#둘째 줄에 N개의 자연수가 주어지고 공백으로 구분, 자연수는 각 1~10,000 사이 수
#입력으로 주어지는 K는 항상 M보다 작거나 같다.

#입력 예시              #출력 예시
#5 8 3                    #46
#2 4 5 4 6

#n = 갯수, m = 더할 최대 숫자 갯수, k = 연속해서 더할 수 같은 인덱스의 최대 갯수
#map을 사용해 입력받는 값들을 int로 처리함
n, m, k = map(int, input().split())

#n개 만큼 입력되는 숫자들
num = list(map(int, input().split()))
print("입력 된 숫자: ", num)

#num 리스트를 sort로 정렬
num.sort()

#더해질 합계
sum = 0

#오름차순으로 정렬된 수 중 가장 큰 수와 두번째로 큰 수를 저장하고, 가장 큰수가 k번 더한 후 두번째 큰 수를 더한다음 가장 큰수를 또 더하게 해줌
big_one = num[n-1]
big_two = num[n-2]

print("입력할 갯수: ", n, "\n더할 횟수: ", m, "\n가장 큰 인덱스 값 연속 더하기 횟수: ", k)
print("가장 큰 수: ", big_one, ", 두 번째 큰 수: ", big_two)
while True:
    for i in range(k):
        #더할 횟수가 0이면 끝내고, 아니라면 연산 후 더할 횟수에 - 1
        if m == 0:
            break
        sum += big_one
        m -= 1
    if m == 0:
        break
    #k번 가장 큰 수 덧셈이 끝났을 때 m이 0이 아니면 두번째 큰 수를 더해주고 더할 횟수 - 1 후 다시 위로 감
    sum += big_two
    m -= 1

print(sum)

#최대 연산 횟수가 10,000 이하라 가능하나, M이 100억 이상이 되면 시간 초과
#보통 시간제한 1초: 최대 100억회 연산
#용량 제한 128MB ~ 512MB -> 데이터 갯수 1천만개 미만으로 해야함



